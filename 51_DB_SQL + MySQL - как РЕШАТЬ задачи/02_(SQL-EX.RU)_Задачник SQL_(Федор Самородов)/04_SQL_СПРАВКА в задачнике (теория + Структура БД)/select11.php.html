<!DOCTYPE html>
<html>
 <head>
	<meta charset="windows-1251">
 <Title>Справка&nbsp;по&nbsp;SQL(DML): Операторы модификации данных</Title>
        <link rel="stylesheet" type="text/css" href="../templates/style.css">
		<link rel="stylesheet" type="text/css" href="../templates/help.css">

    	<link rel="stylesheet" title="Default" href="../help/styles/default.css">
        <script type="text/javascript" src="../help/highlight.js"></script>
        <meta name="Description" content="Самоучитель SQL. Синтаксис операторов SELECT, INSERT, UPDATE, DELETE в примерах и задачах. Дистанционное обучение языку баз данных SQL. Интерактивные упражнения по оператору SELECT языка SQL. Тестирование по SQL. ">
        <meta name="Keywords" content="SQL, руководство, справочник по SQL, справка по языку SQL, sql запросы, упражнения, тестирование, обучение, операторы sql, SELECT, FROM, JOIN, WHERE, GROUP BY, HAVING, INSERT, UPDATE, DELETE, структурированный язык запросов">
        <META NAME="abstract" CONTENT="Справочник по языку манипуляции данными SQL с примерами использования всех синтаксических конструкций стандарта языка DML. Особенности использования в MS SQL Server. Справочник сопровождается упражнениями, выполняемыми в режиме он-лайн на сайте.">
        <META NAME="title" CONTENT="Справочник по языку манипуляции данными SQL с примерами использования всех синтаксических конструкций стандарта языка DML. Особенности использования в MS SQL Server. Справочник сопровождается упражнениями, выполняемыми в режиме он-лайн на сайте.">
        <script LANGUAGE="JAVASCRIPT" src="/js/main.js"></script>
 </head>
 <body bgcolor="#F5F5F5">
<!-- LM -->
<script async="async" src="https://w.uptolike.com/widgets/v1/zp.js?pid=48720"></script>
<!-- LM -->

 <A name="ref_beg"></a>
<!-- 728*90 Advertur.ru start -->
<div id="advertur_76084"></div><script type="text/javascript">
    (function(w, d, n) {
        w[n] = w[n] || [];
        w[n].push({
            section_id: 76084,
            place: "advertur_76084",
            width: 728,
            height: 90
        });
    })(window, document, "advertur_sections");
</script>
<script type="text/javascript" src="//ddnk.advertur.ru/v1/s/loader.js" async></script>
<!-- 728*90 Advertur.ru end -->
<form name="frmtpl">
<table width="98%" border="0" cellpadding="5" align="center">
    <tr>
        <td width="33%" bgcolor="#CCCCCC" valign="middle"><b><a class='none' href="/help/">Синтаксис SQL</a></b></td>
        <td width="33%" bgcolor="#CCCCCC" align="center" valign="middle">
         Language&nbsp;<select name="lsttpl" OnChange="Sel_Lang(document.frmtpl.lsttpl.selectedIndex)"><option value="0" selected> Русский <option value="1" > English </select>
        </td>
        <td width="33%" bgcolor="#CCCCCC" align="right" valign="middle"><a href=select0.php.html>Оглавл.</a>&nbsp;<a href=select1.php.html>1</a>&nbsp;<a href=select2.php.html>2</a>&nbsp;<a href=select3.php.html>3</a>&nbsp;<a href=select4.php.html>4</a>&nbsp;<a href=select5.php.html>5</a>&nbsp;<a href=select6.php.html>6</a>&nbsp;<a href=select7.php.html>7</a>&nbsp;<a href=select8.php.html>8</a>&nbsp;<a href=select9.php.html>9</a>&nbsp;<a href=select10.php.html>10</a>&nbsp;[<b>11</b>]&nbsp;<a href=select12.php.html>12</a>&nbsp;<a href=select13.php.html>13</a>&nbsp;<a href=select14.php.html>14</a>&nbsp;<a href=select15.php.html>15</a>&nbsp;<a href=select16.php.html>16</a>&nbsp;<a href=select17.php.html>17</a>&nbsp;<a href=select18.php.html>18</a>&nbsp;<a href=select19.php.html>19</a>&nbsp;<a href=select20.php.html>20</a>&nbsp;
<!--Rambler Top100-->
<div style="display:none">
<script id="top100Counter" type="text/javascript" src="http://cnt.rambler.ru/top100.jcn?718545">
</script>
<noscript><a href="http://top100.rambler.ru/top100/">
<img src="http://cnt.rambler.ru/top100.cnt?718545" alt="Rambler's Top100" width="81" height="63" border="0" /></a></noscript>
</div>
<!--end of Top100-->
        </td>
</tr>
</table>
</form><h1>Операторы модификации данных</h1>
<div style="width:90%;position:relative;left:5%;">
<p>Язык манипуляции данными (DML - Data Manipulation Language) помимо оператора <b>SELECT</b>, осуществляющего извлечение информации из базы данных, включает операторы, изменяющие состояние данных. Этими операторами являются:
</p>
<TABLE border="0" cellpadding="5"  align="center">

        <TR>
                <TD BGCOLOR="#CCCCCC"> INSERT</TD>
                <TD BGCOLOR="#CCCCCC">Добавление записей (строк) в таблицу БД </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">UPDATE</TD>
                <TD BGCOLOR="#DDDDDD">Обновление данных в столбце таблицы БД </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">DELETE</TD>
                <TD BGCOLOR="#CCCCCC">Удаление записей из таблицы БД</TD>
        </TR>
</table>
<!-- 728*90 Advertur.ru start -->
<div id="advertur_2087"></div><script type="text/javascript">
    (function(w, d, n) {
        w[n] = w[n] || [];
        w[n].push({
            section_id: 2087,
            place: "advertur_2087",
            width: 728,
            height: 90
        });
    })(window, document, "advertur_sections");
</script>
<script type="text/javascript" src="//ddnk.advertur.ru/v1/s/loader.js" async></script>
<!-- 728*90 Advertur.ru end -->
<h2>Оператор INSERT</h2>
<p>
Оператор <b>INSERT</b> вставляет новые строки в таблицу. При этом значения столбцов могут представлять собой
литеральные константы либо являться результатом выполнения подзапроса. В первом случае для вставки
каждой строки используется отдельный оператор <b>INSERT</b>; во втором случае будет вставлено столько строк,
сколько возвращается подзапросом.
<br>Синтаксис оператора
<p>INSERT INTO &lt;<i>имя таблицы</i>>[(&lt;<i>имя столбца</i>>,...)]
<br>&nbsp;&nbsp;&nbsp;{VALUES (&lt; <i>значение столбца</i>>,…)}
<br>&nbsp;&nbsp;&nbsp;| &lt;<i>выражение запроса</i>>
<br>&nbsp;&nbsp;&nbsp;| {DEFAULT VALUES};
</p>
<p>Как видно из представленного синтаксиса, список столбцов не является обязательным.
 В том случае, если он отсутствует, список вставляемых значений должен быть полный,
 т.е. обеспечивать значения для всех столбцов таблицы. При этом порядок значений должен соответствовать
  порядку столбцов, заданному оператором <b>CREATE TABLE</b> для таблицы, в которую вставляются строки.
  Кроме того, каждое из этих значений должно быть того же типа (или приводиться к нему), что и тип, определенный для
  соответствующего столбца в операторе <b>CREATE TABLE</b>.
   В качестве примера рассмотрим вставку строки в таблицу <i>Product</i>, созданную следующим оператором
   <b>CREATE TABLE</b>:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
   CREATE TABLE [dbo].[product] (
<br>&nbsp;&nbsp;&nbsp;	[maker] [char] (1) NOT NULL ,
<br>&nbsp;&nbsp;&nbsp;	[model] [varchar] (4) NOT NULL ,
<br>&nbsp;&nbsp;&nbsp;	[type] [varchar] (7) NOT NULL
)</td></tr></table>
<p>Пусть требуется добавить в эту таблицу модель ПК 1157 производителя B. Это можно сделать следующим оператором:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product VALUES ('B', 1157, 'PC');
</td></tr></table>
<p>Если задать список столбцов, то можно изменить &quot;естественный&quot; порядок их следования:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product (type, model, maker) VALUES ('PC', 1157, 'B');
</td></tr></table>
<p>Казалось бы, это совершенно излишняя возможность, которая делает конструкцию только более громоздкой. Однако она становится выигрышной, если столбцы имеют значения по умолчанию. Рассмотрим следующую структуру таблицы:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
CREATE TABLE [product_D] (
<br>&nbsp;&nbsp;&nbsp;	[maker] [char] (1) NULL ,
<br>&nbsp;&nbsp;&nbsp;	[model] [varchar] (4) NULL ,
<br>&nbsp;&nbsp;&nbsp;	[type] [varchar] (7) NOT NULL DEFAULT 'PC'
)
</td></tr></table>
<p>Отметим, что здесь значения всех столбцов имеют значения по умолчанию
(первые два - NULL, а последний столбец - <i>type</i> - 'PC'). Теперь мы могли бы написать:
</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D (model, maker) VALUES (1157, 'B');
</td></tr></table>

<p>В этом случае отсутствующее значение при вставке строки будет заменено значением по умолчанию - 'PC'.
 Заметим, что если для столбца в операторе <b>CREATE TABLE</b> не указано значение по умолчанию и не указано
 ограничение <b>NOT NULL</b>, запрещающее использование NULL в данном столбце таблицы, то подразумевается значение по умолчанию NULL. </p>
<p>Возникает вопрос: а можно ли не указывать список столбцов и, тем не менее, воспользоваться значениями
по умолчанию? Ответ положительный. Для этого нужно вместо явного указания значения использовать зарезервированное слово <b>DEFAULT</b>:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D VALUES ('B', 1158, DEFAULT);
</td></tr></table>
<p>Поскольку все столбцы имеют значения по умолчанию,
 для вставки строки со значениями по умолчанию можно было бы написать:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D VALUES (DEFAULT, DEFAULT, DEFAULT);
</td></tr></table>
<p>Однако для этого случая предназначена специальная конструкция <b>DEFAULT VALUES</b>
(смотри синтаксис оператора), с помощью которой вышеприведенный оператор можно переписать в виде</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D DEFAULT VALUES;
</td></tr></table>
<p>Заметим, что при вставке строки в таблицу проверяются все ограничения, наложенные на данную таблицу. Это могут быть
 ограничения первичного ключа или уникального индекса, проверочные ограничения типа <b>CHECK</b>, ограничения
 ссылочной целостности. В случае нарушения какого-либо ограничения вставка строки будет отвергнута.</p>
<p>Рассмотрим теперь случай использования подзапроса. Пусть нам требуется вставить в таблицу <i>Product_D</i> все строки из таблицы <i>Product</i>,
 относящиеся к моделям персональных компьютеров (<i>type</i> = 'PC'). Поскольку необходимые нам значения уже
 имеются в некоторой таблице, то формирование вставляемых строк вручную, во-первых, является неэффективным,
 а, во-вторых, может допускать ошибки ввода. Использование подзапроса решает эти проблемы:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D SELECT * FROM Product WHERE type = 'PC';
</td></tr></table>
<p>Использование в подзапросе символа &quot;*&quot; является
 в данном случае оправданным, т.к. порядок следования столбцов является одинаковым для обеих таблиц.
 Если бы это было не так, следовало бы использовать список столбцов либо в операторе <b>INSERT</b>,
 либо в подзапросе, либо в обоих местах, который приводил бы в соответствие порядок следования столбцов:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D(maker, model, type)
<br>&nbsp;&nbsp;&nbsp;SELECT * FROM Product WHERE type = 'PC';
</td></tr></table>
<p>или</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D
<br>&nbsp;&nbsp;&nbsp;SELECT maker, model, type FROM Product WHERE type = 'PC';
</td></tr></table>
<p>или</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D(maker, model, type)
<br>&nbsp;&nbsp;&nbsp;SELECT maker, model, type FROM Product WHERE type = 'PC';
</td></tr></table>
<p>Здесь, также как и ранее, можно указывать не все столбцы, если требуется использовать имеющиеся значения по умолчанию, например:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D (maker, model)
<br>&nbsp;&nbsp;&nbsp;SELECT maker, model FROM Product WHERE type = 'PC';
</td></tr></table>
<p>В данном случае в столбец <i>type</i> таблицы <i>Product_D</i> будет подставлено значение по умолчанию 'PC' для всех вставляемых строк.</p>
<p>Отметим, что при использовании подзапроса, содержащего предикат, будут вставлены только те строки, для которых значение предиката равно TRUE (не UNKNOWN!). Другими словами, если бы столбец <i>type</i> в таблице <i>Product</i> допускал бы NULL-значение, и это значение присутствовало бы в ряде строк, то эти строки не были бы вставлены в таблицу <i>Product_D</i>.</p>
<p>Преодолеть ограничение на вставку одной строки в операторе <b>INSERT</b> при использовании <b>VALUES</b> позволяет искусственный прием использования подзапроса, формирующего строку с предложением <b>UNION ALL</b>. Так если нам требуется вставить несколько строк при помощи одного оператора <b>INSERT</b>, можно написать:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Product_D
<br>&nbsp;&nbsp;&nbsp;SELECT 'B' AS maker, 1158 AS model, 'PC' AS type
<br>&nbsp;&nbsp;&nbsp;UNION ALL
<br>&nbsp;&nbsp;&nbsp;SELECT 'C', 2190, 'Laptop'
<br>&nbsp;&nbsp;&nbsp;UNION ALL
<br>&nbsp;&nbsp;&nbsp;SELECT 'D', 3219, 'Printer';
</td></tr></table>
<p>Использование <b>UNION ALL</b> предпочтительней <b>UNION</b> даже, если гарантировано отсутствие строк-дубликатов, т.к. в этом случае не будет выполняться проверка для исключения дубликатов.</p>
<a name=ident></a>
<h2>Вставка строк в таблицу, содержащую автоинкрементируемое поле</h2>
<p>Многие коммерческие продукты допускают использование автоинкрементируемых столбцов в таблицах, т.е. полей, значение которых формируется автоматически при добавлении новых записей. Такие столбцы широко используются в качестве первичных ключей таблицы, т.к. они автоматически обеспечивают уникальность. Типичным примером столбца такого типа является последовательный счетчик, который при вставке строки генерирует значение на единицу большее предыдущего значения (значения, полученного при вставке предыдущей строки).</p>
<p>Ниже приводится пример создания таблицы с автоинкрементируемым столбцом (<i>code</i>) в MS SQL Server.</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
CREATE TABLE [Printer_Inc] (
<br>&nbsp;&nbsp;&nbsp;	[code] [int] IDENTITY(1,1) PRIMARY KEY ,
<br>&nbsp;&nbsp;&nbsp;	[model] [varchar] (4) NOT NULL ,
<br>&nbsp;&nbsp;&nbsp;	[color] [char] (1) NOT NULL ,
<br>&nbsp;&nbsp;&nbsp;	[type] [varchar] (6) NOT NULL ,
<br>&nbsp;&nbsp;&nbsp;	[price] [float] NOT NULL
)</td></tr></table>
<p>Автоинкрементируемое поле определяется посредством конструкции <b>IDENTITY (1, 1)</b>. При этом первый параметр свойства <b>IDENTITY (1)</b> определяет, с какого значения начнется отсчет, а второй - какой шаг будет использоваться для приращения значения. Таким образом, в нашем примере первая вставленная запись будет иметь в столбце <i>code</i> значение 1, вторая - 2 и т.д.</p>
<p>Поскольку в поле <i>code</i>  значение формируется автоматически, оператор</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Printer_Inc VALUES (15, 3111, 'y', 'laser', 2599);
</td></tr></table>
<p>приведет к ошибке, даже если в таблице нет строки со значением в поле <i>code</i>, равным 15. Поэтому для вставки строки в таблицу просто не будем указывать это поле точно так же, как и в случае использования значения по умолчанию, т.е.</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
INSERT INTO Printer_Inc (model, color, type, price)
<br>&nbsp;&nbsp;&nbsp;	VALUES (3111, 'y', 'laser', 2599);
</td></tr></table>
<p>В результате выполнения этого оператора в таблицу <i>Printer_Inc</i> будет вставлена информация о модели
 3111 цветного лазерного принтера, стоимость которого равна $2599. В поле <b>code</b> окажется значение, которое только случайно может оказаться равным 15. В большинстве случаев этого оказывается достаточно, т.к. значение автоинкрементируемого поля, как правило, не несет никакой информации; главное, чтобы оно было уникальным.</p>
<p>Однако бывают случаи, когда требуется подставить вполне конкретное значение в автоинкрементируемое поле. Например, нужно перенести уже имеющиеся данные во вновь создаваемую структуру; при этом эти данные участвуют в связи &quot;один-ко-многим&quot; со стороны &quot;один&quot;. Таким образом, мы не можем допустить тут произвола. С другой стороны, нам не хочется отказываться от автоинкрементируемого поля, т.к. оно упростит обработку данных при последующей эксплуатации базы данных.</p>
<p>Поскольку стандарт языка SQL не предполагает наличия автоинкрементируемых полей, то соответственно не существует и единого подхода. Здесь мы покажем, как это реализуется в MS SQL Server. Оператор</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SET IDENTITY_INSERT &lt; <i>имя таблицы</i> &gt; { ON | OFF };
</td></tr></table>
<p>отключает (значение ON) или включает (OFF) использование автоинкремента. Поэтому чтобы вставить строку со значением 15 в поле <i>code</i>, нужно написать</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SET IDENTITY_INSERT Printer_Inc  ON;
<br>INSERT INTO Printer_Inc(code, model, color, type, price)
<br>&nbsp;&nbsp;&nbsp;	VALUES (15, 3111, 'y', 'laser', 2599);
</td></tr></table>
<p>Обратите внимание, что список столбцов в этом случае является обязательным, т.е. мы не можем написать так:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SET IDENTITY_INSERT Printer_Inc  ON;
<br>INSERT INTO Printer_Inc
<br>&nbsp;&nbsp;&nbsp;VALUES (15, 3111, 'y', 'laser', 2599);
</td></tr></table>
<p>ни, тем более, так    </p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SET IDENTITY_INSERT Printer_Inc  ON;
<br>INSERT INTO Printer_Inc(model, color, type, price)
<br>&nbsp;&nbsp;&nbsp;VALUES (3111, 'y', 'laser', 2599);
</td></tr></table>
<p>В последнем случае в пропущенный столбец <i>code</i> значение не может быть подставлено автоматически, т.к. автоинкрементирование отключено.</p>
<p>Важно отметить, что если значение 15 окажется максимальным в столбце <i>code</i>,то далее нумерация продолжится со значения 16. Естественно, если включить автоинкрементирование: <b>SET IDENTITY_INSERT Printer_Inc  OFF</b>.</p>
<p>Наконец, рассмотрим пример вставки данных из таблицы <i>Product</i> в таблицу <i>Product_Inc</i>, сохранив значения в поле <i>code</i>:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SET IDENTITY_INSERT Printer_Inc ON;
<br>INSERT INTO Printer_Inc(code, model,color,type,price)
<br>&nbsp;&nbsp;&nbsp;SELECT * FROM Printer;
</td></tr></table>
<p>По поводу автоинкрементируемых столбцов следует еще сказать следующее. Пусть последнее значение в поле <i>code</i> было равно 16, после чего строка с этим значением была удалена. Какое значение будет в этом столбце после вставки новой строки? Правильно, 17, т.к. последнее значение счетчика сохраняется, несмотря на удаление строки, его содержащей. Поэтому нумерация значений в результате удаления и добавления строк не будет последовательной. Это является еще одной причиной для вставки строки с заданным (пропущенным) значением в автоинкрементируемом столбце.</p>
</div><center>
<br><br>
<small>

</small>
<br><br>
</center>
<p></p>
<!-- раскраска -->
  	<script type="text/javascript">
      hljs.initHighlightingOnLoad('sql');
    </script>

<center>
<a href="select10.php.html">Назад</a> | <a href="select0.php.html">Содержание</a> | <a href="select12.php.html">Вперед</a><br><br>
<!-- Яндекс.Директ -->
<script type="text/javascript">
yandex_partner_id = 184442;
yandex_site_bg_color = 'FFFFFF';
yandex_ad_format = 'direct';
yandex_font_size = 0.9;
yandex_direct_type = 'horizontal';
yandex_direct_border_type = 'block';
yandex_direct_limit = 2;
yandex_direct_title_font_size = 2;
yandex_direct_links_underline = false;
yandex_direct_header_bg_color = 'FEEAC7';
yandex_direct_border_color = 'FBE5C0';
yandex_direct_title_color = '0000CC';
yandex_direct_url_color = '006600';
yandex_direct_text_color = '000000';
yandex_direct_hover_color = '0066FF';
yandex_direct_sitelinks_color = '0000CC';
yandex_direct_favicon = true;
yandex_no_sitelinks = false;
document.write('<scr'+'ipt type="text/javascript" src="//an.yandex.ru/system/context.js"></scr'+'ipt>');
</script><br></center>

<br>
<table width="98%" border="0" align="center" cellpadding="0" cellspacing="0" bgcolor="#CCCCCC" valign="middle">
 <tr>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/" style="font-size: 8pt;">Начало</A></td>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/exercises.php.html" target="exercises" style="font-size: 8pt;">Упражнения <b>SELECT (рейтинговые этапы)</b></A></td>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/dmlexercises.php.html" target="exercises" style="font-size: 8pt;">Упражнения <b>DML</b></A></td>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/developers.php.html" style="font-size: 8pt;">Разработчики</A></td>
 <td align="left" width="20%">
<!--begin of Top100 logo-->
<noindex>
<a href="http://top100.rambler.ru/top100/">
<img src="http://top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100" width="88" height="31" border="0"></a>
</noindex>
<!--end of Top100 logo -->

<!--LiveInternet counter--><script language="JavaScript"><!--
document.write('<a href="http://www.liveinternet.ru/click" '+
'target="_blank"><img src="http://counter.yadro.ru/hit?t16.2;r'+
escape(document.referrer)+((typeof(screen)=='undefined')?'':
';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
';'+Math.random()+'" title="liveinternet.ru: число просмотров и посетителей за сутки и за сегодня" border="0" width="88" height="31"></a>')//--></script>
<!--/LiveInternet-->

<!--uptolike -->
<script type="text/javascript">(function(w,doc) {
if (!w.__utlWdgt ) {
    w.__utlWdgt = true;
    var d = doc, s = d.createElement('script'), g = 'getElementsByTagName';
    s.type = 'text/javascript'; s.charset='UTF-8'; s.async = true;
    s.src = ('https:' == w.location.protocol ? 'https' : 'http')  + '://w.uptolike.com/widgets/v1/uptolike.js';
    var h=d[g]('body')[0];
    h.appendChild(s);
}})(window,document);
</script>
<div data-background-alpha="0.0" data-orientation="horizontal" data-text-color="000000" data-share-shape="round-rectangle" data-buttons-color="ff9300" data-sn-ids="fb.tw.ok.vk.gp.mr." data-counter-background-color="ffffff" data-share-counter-size="10" data-share-size="20" data-background-color="ededed" data-share-counter-type="common" data-pid="1257631" data-counter-background-alpha="1.0" data-share-style="1" data-mode="share" data-following-enable="false" data-like-text-enable="false" data-selection-enable="true" data-icon-color="ffffff" class="uptolike-buttons" ></div>
<!--uptolike -->

 </td></tr>
</table>
</body>

<style>
DIV {
    width: 90%;
    position: relative;
    left: 5%;
	
    COLOR: black;
    FONT-FAMILY: Verdana,Arial,Helvetica;
    FONT-SIZE: 12px;
    FONT-WEIGHT: normal;
    TEXT-ALIGN: justify;
    TEXT-DECORATION: none;
}

H2 {
    COLOR: #004040;
    FONT-FAMILY: Arial,Helvetica;
    FONT-SIZE: 13pt;
    FONT-WEIGHT: bold;
    LINE-HEIGHT: 20px;
    TEXT-ALIGN: center;
    text-decoration: none;
}
h2 {
    display: block;
    
    margin-block-start: 0.83em;
    margin-block-end: 0.83em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    
}

.keyword {
    color: #00f;
}
</style>

</html>