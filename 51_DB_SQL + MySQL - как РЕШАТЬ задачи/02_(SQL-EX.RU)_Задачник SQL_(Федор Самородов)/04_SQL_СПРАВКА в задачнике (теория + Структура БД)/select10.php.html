<!DOCTYPE html>
<html>
 <head>
 
 <style>
DIV {
    width: 90%;
    position: relative;
    left: 5%;
	
    COLOR: black;
    FONT-FAMILY: Verdana,Arial,Helvetica;
    FONT-SIZE: 12px;
    FONT-WEIGHT: normal;
    TEXT-ALIGN: justify;
    TEXT-DECORATION: none;
}

H2 {
    COLOR: #004040;
    FONT-FAMILY: Arial,Helvetica;
    FONT-SIZE: 13pt;
    FONT-WEIGHT: bold;
    LINE-HEIGHT: 20px;
    TEXT-ALIGN: center;
    text-decoration: none;
}
h2 {
    display: block;
    
    margin-block-start: 0.83em;
    margin-block-end: 0.83em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    
}

.keyword {
    color: #00f;
}
</style>


	<meta charset="windows-1251">
 <Title>Справка&nbsp;по&nbsp;SQL(DML): Функции работы со строками в MS SQL SERVER 2005</Title>
        <link rel="stylesheet" type="text/css" href="../templates/style.css">
		<link rel="stylesheet" type="text/css" href="../templates/help.css">

    	<link rel="stylesheet" title="Default" href="../help/styles/default.css">
        <script type="text/javascript" src="../help/highlight.js"></script>
        <meta name="Description" content="Самоучитель SQL. Синтаксис операторов SELECT, INSERT, UPDATE, DELETE в примерах и задачах. Дистанционное обучение языку баз данных SQL. Интерактивные упражнения по оператору SELECT языка SQL. Тестирование по SQL. ">
        <meta name="Keywords" content="SQL, руководство, справочник по SQL, справка по языку SQL, sql запросы, упражнения, тестирование, обучение, операторы sql, SELECT, FROM, JOIN, WHERE, GROUP BY, HAVING, INSERT, UPDATE, DELETE, структурированный язык запросов">
        <META NAME="abstract" CONTENT="Справочник по языку манипуляции данными SQL с примерами использования всех синтаксических конструкций стандарта языка DML. Особенности использования в MS SQL Server. Справочник сопровождается упражнениями, выполняемыми в режиме он-лайн на сайте.">
        <META NAME="title" CONTENT="Справочник по языку манипуляции данными SQL с примерами использования всех синтаксических конструкций стандарта языка DML. Особенности использования в MS SQL Server. Справочник сопровождается упражнениями, выполняемыми в режиме он-лайн на сайте.">
        <script LANGUAGE="JAVASCRIPT" src="/js/main.js"></script>
 </head>
 <body bgcolor="#F5F5F5">
<!-- LM -->
<script async="async" src="https://w.uptolike.com/widgets/v1/zp.js?pid=48720"></script>
<!-- LM -->

 <A name="ref_beg"></a>
<!-- 728*90 Advertur.ru start -->
<div id="advertur_76084"></div><script type="text/javascript">
    (function(w, d, n) {
        w[n] = w[n] || [];
        w[n].push({
            section_id: 76084,
            place: "advertur_76084",
            width: 728,
            height: 90
        });
    })(window, document, "advertur_sections");
</script>
<script type="text/javascript" src="//ddnk.advertur.ru/v1/s/loader.js" async></script>
<!-- 728*90 Advertur.ru end -->
<form name="frmtpl">
<table width="98%" border="0" cellpadding="5" align="center">
    <tr>
        <td width="33%" bgcolor="#CCCCCC" valign="middle"><b><a class='none' href="/help/">Синтаксис SQL</a></b></td>
        <td width="33%" bgcolor="#CCCCCC" align="center" valign="middle">
         Language&nbsp;<select name="lsttpl" OnChange="Sel_Lang(document.frmtpl.lsttpl.selectedIndex)"><option value="0" selected> Русский <option value="1" > English </select>
        </td>
        <td width="33%" bgcolor="#CCCCCC" align="right" valign="middle"><a href=select0.php.html>Оглавл.</a>&nbsp;<a href=select1.php.html>1</a>&nbsp;<a href=select2.php.html>2</a>&nbsp;<a href=select3.php.html>3</a>&nbsp;<a href=select4.php.html>4</a>&nbsp;<a href=select5.php.html>5</a>&nbsp;<a href=select6.php.html>6</a>&nbsp;<a href=select7.php.html>7</a>&nbsp;<a href=select8.php.html>8</a>&nbsp;<a href=select9.php.html>9</a>&nbsp;[<b>10</b>]&nbsp;<a href=select11.php.html>11</a>&nbsp;<a href=select12.php.html>12</a>&nbsp;<a href=select13.php.html>13</a>&nbsp;<a href=select14.php.html>14</a>&nbsp;<a href=select15.php.html>15</a>&nbsp;<a href=select16.php.html>16</a>&nbsp;<a href=select17.php.html>17</a>&nbsp;<a href=select18.php.html>18</a>&nbsp;<a href=select19.php.html>19</a>&nbsp;<a href=select20.php.html>20</a>&nbsp;
<!--Rambler Top100-->
<div style="display:none">
<script id="top100Counter" type="text/javascript" src="http://cnt.rambler.ru/top100.jcn?718545">
</script>
<noscript><a href="http://top100.rambler.ru/top100/">
<img src="http://cnt.rambler.ru/top100.cnt?718545" alt="Rambler's Top100" width="81" height="63" border="0" /></a></noscript>
</div>
<!--end of Top100-->
        </td>
</tr>
</table>
</form><a name=string_fun></a>
<h1>Функции работы со строками в MS SQL SERVER 2005</h1>
<div style="width:90%;position:relative;left:5%;">
<p>Вот полный перечень функций работы со строками, взятый из BOL:</p>
<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD BGCOLOR="#DDDDDD"><b>ASCII</b></TD>
                <TD BGCOLOR="#DDDDDD"><b>NCHAR</b> </TD>
                <TD BGCOLOR="#DDDDDD"><b>SOUNDEX</b> </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC"><b>CHAR</b></TD>
                <TD BGCOLOR="#CCCCCC"><b>PATINDEX</b> </TD>
                <TD BGCOLOR="#CCCCCC"><b>SPACE</b> </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD"><b>CHARINDEX</b></TD>
                <TD BGCOLOR="#DDDDDD"><b>REPLACE</b> </TD>
                <TD BGCOLOR="#DDDDDD"><b>STR</b> </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC"><b>DIFFERENCE</b></TD>
                <TD BGCOLOR="#CCCCCC"><b>QUOTENAME</b> </TD>
                <TD BGCOLOR="#CCCCCC"><b>STUFF</b> </TD>
       </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD"><b>LEFT</b></TD>
                <TD BGCOLOR="#DDDDDD"><b>REPLICATE</b> </TD>
                <TD BGCOLOR="#DDDDDD"><b>SUBSTRING</b> </TD>
       </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC"><b>LEN</b></TD>
                <TD BGCOLOR="#CCCCCC"><b>REVERSE</b> </TD>
                <TD BGCOLOR="#CCCCCC"><b>UNICODE</b> </TD>
       </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD"><b>LOWER</b></TD>
                <TD BGCOLOR="#DDDDDD"><b>RIGHT</b> </TD>
                <TD BGCOLOR="#DDDDDD"><b>UPPER</b> </TD>
       </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC"><b>LTRIM</b></TD>
                <TD BGCOLOR="#CCCCCC"><b>RTRIM</b> </TD>
                <TD BGCOLOR="#CCCCCC"> </TD>

        </TR>
</TABLE>
<!-- 728*90 Advertur.ru start -->
<div id="advertur_2087"></div><script type="text/javascript">
    (function(w, d, n) {
        w[n] = w[n] || [];
        w[n].push({
            section_id: 2087,
            place: "advertur_2087",
            width: 728,
            height: 90
        });
    })(window, document, "advertur_sections");
</script>
<script type="text/javascript" src="//ddnk.advertur.ru/v1/s/loader.js" async></script>
<!-- 728*90 Advertur.ru end -->
<p>Начнем с двух взаимно обратных функций - <b>ASCII</b> и <b>CHAR</b>.</p>
<p>Функция ASCII возвращает ASCII-код крайнего левого символа строкового выражения, являющегося аргументом функции.</p>
<p>Вот, например, как можно определить, сколько имеется разных букв, с которых начинаются названия кораблей в таблице Ships:</p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">SELECT COUNT(DISTINCT ASCII(name)) FROM Ships  </td></tr> </table><br>

<p>Результат - 11. Чтобы выяснить, какие это буквы, мы можем применить функцию CHAR, которая возвращает символ по известному ASCII-коду (от 0 до 255):</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">SELECT DISTINCT CHAR(ASCII(name)) FROM Ships ORDER BY 1</td></tr> </table><br>
<p>Следует отметить, что аналогичный результат можно получить проще с помощью еще одной функции - <b>LEFT</b>, которая имеет следующий синтаксис:</p>

<p><b>LEFT (&lt;<i>строковое выражение</i>>, &lt;<i>целочисленное выражение</i>> )</b>    </p>
<p>и вырезает заданное вторым аргументом число символов слева из строки, являющейся первым аргументом. Итак,</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">SELECT DISTINCT LEFT(name, 1) FROM Ships ORDER BY 1 </td></tr> </table><br>
<p>А вот как, например, можно получить таблицу кодов всех алфавитных символов:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT CHAR(ASCII('a')+ num-1) letter, ASCII('a')+ num - 1 [code]<br>
FROM (SELECT 5*5*(a-1)+5*(b-1) + c AS num <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM (SELECT 1 a UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) x<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             CROSS JOIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (SELECT 1 b UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) y<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             CROSS JOIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (SELECT 1 c UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) x<br>
WHERE ASCII('a')+ num -1 BETWEEN ASCII('a') AND ASCII('z')
</td></tr> </table><br>
<p>Тех, кто еще не в курсе генерации числовой последовательности, отсылаю к соответствующей <noindex><a href="http://sqlbooks.ru/readarticle.aspx?part=09&file=addition02&sm=id9_1" target="_blank">статье</a> </noindex>. </p>
<p>Как известно, коды строчных и прописных букв отличаются. Поэтому чтобы получить полный набор без переписывания запроса, достаточно просто дописать к вышеприведенному коду аналогичный:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
UNION<br>
SELECT CHAR(ASCII('A')+ num-1) letter, ASCII('A')+ num - 1 [code]<br>
FROM (SELECT 5*5*(a-1)+5*(b-1) + c AS num<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM (SELECT 1 a UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) x<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             CROSS JOIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (SELECT 1 b UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) y <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             CROSS JOIN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         (SELECT 1 c UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) z <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) x <br>
WHERE ASCII('A')+ num -1 BETWEEN ASCII('A') AND ASCII('Z')<br>
</td></tr> </table><br>
<p>Чтобы таблица выглядела более патриотично, достаточно заменить латинские буквы "a" и "A" на неотличимые на взгляд русские - "а" и "А", а "z" и "Z" на "я" и "Я". Вот только буквы "ё" вы не увидите в этой таблице, т.к. в кодовой таблице ASCII эти символы лежат отдельно, что легко проверить:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT ASCII('ё')
UNION ALL
SELECT ASCII('Ё')
</td></tr> </table><br>
<p>Я полагаю, что не будет сложным добавить эту букву в таблицу, если потребуется.</p>
<p>Рассмотрим теперь задачу определения нахождения искомой подстроки в строковом выражении. Для этого могут использоваться две функции - <b>CHARINDEX</b> и <b>PATINDEX</b>. Обе они возвращают начальную позицию (позицию первого символа подстроки) подстроки в строке. Функция CHARINDEX имеет синтаксис:</p>
 <p><b>CHARINDEX (<i>искомое_выражение</i>, <i>строковое_выражение</i>[, <i>стартовая_позиция</i>])</b></p>
 <p>Здесь необязательный целочисленный параметр <i>стартовая_позиция</i> определяет позицию в строковом выражении, начиная с которой выполняется поиск <i>искомого_выражения</i> . Если этот параметр опущен, поиск выполняется от начала <i>строкового_выражения</i>. Например, запрос</p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3"> SELECT name FROM Ships WHERE CHARINDEX('sh', name) > 0</td></tr> </table><br>
<p>будет выводить те корабли, в которых имеется сочетание символов "sh". Здесь используется тот факт, что если искомая строка не будет обнаружена, то функция CHARINDEX возвращает 0. Результат выполнения запроса будет содержать следующие корабли:</p>

<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD ALIGN="center" BGCOLOR="#D3DCE3"><B>name</B></TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">Kirishima</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">Musashi</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">Washington</TD>
        </TR>
</TABLE>

<p>Следует отметить, что если искомая подстрока либо строковое выражение есть NULL, то результатом функции тоже будет NULL.</p>
<p>Следующий пример определяет позиции первого и второго вхождения символа "a" в имени корабля "California"</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT CHARINDEX('a',name) first_a,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   CHARINDEX('a', name, CHARINDEX('a', name)+1) second_a <br>
FROM Ships WHERE name='California'
</td></tr> </table><br>
<p>Обратите внимание, что при определении второго символа в функции используется стартовая позиция, которой является позиция следующего за первой буквой "a" символа - CHARINDEX('a', name)+1. Правильность результата - 2 и 10 - легко проверить :-).</p>
<p>Функция PATINDEX имеет синтаксис:</p>
<p><b>PATINDEX ('%<i>образец</i>%' , <i>строковое_выражение</i>)</b> </p>
<p>Главное отличие этой функции от CHARINDEX заключается в том, что поисковая строка может содержать подстановочные знаки - % и _. При этом концевые знаки "%" являются обязательными. Например, использование этой функции в первом примере будет иметь вид</p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">SELECT name FROM Ships WHERE PATINDEX('%sh%', name) > 0 </td></tr> </table><br>
<p>А вот, например, как можно найти имена кораблей, которые содержат последовательность из трех символов, первый и последний из которых есть "e":</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">SELECT name FROM Ships WHERE PATINDEX('%e_e%', name) >0</td></tr> </table><br>
<p>Результат выполнения этого запроса выглядит следующим образом:</p>

<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD ALIGN="center" BGCOLOR="#D3DCE3"><B>name</B></TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">Revenge</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">Royal Sovereign</TD>
        </TR>
</TABLE>
<p>Парная к <b>LEFT</b> функция <b>RIGHT</b> возвращает заданное число символов справа из строкового выражения:</p>
<p><b>RIGHT(&lt;<i>строковое выражения</i>>,&lt;<i>число символов</i>>)</b> </p>
<p>Вот, например, как можно определить имена кораблей, которые начинаются и заканчиваются на одну и ту же букву:</p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">SELECT name FROM Ships WHERE LEFT(name, 1) = RIGHT(name, 1)
</td></tr> </table><br>
<p>То, что в результате мы получим пустой результирующий набор, означает, что таких кораблей в базе данных нет. Давайте возьмем комбинацию значений - класс и имя корабля. </p>
<p>Соединение двух строковых значений в одно называется <b>конкатенацией</b>, и в <b>SQL Server</b> для этой операции используется знак "+" (в стандарте "||"). Итак,</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT * FROM (<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT class +' '+ name AS cn FROM Ships<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    ) x <br>
WHERE LEFT(cn, 1)=RIGHT(cn, 1)
</td></tr> </table><br>

<p>Здесь мы разделяем пробелом имя класса и имя корабля. Кроме того, чтобы не повторять всю конструкцию в качестве аргумента функции, используем подзапрос. Результат будет иметь вид:</p>
<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD ALIGN="center" BGCOLOR="#D3DCE3"><B>cn</B></TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">Iowa Missouri </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">North Carolina Washington</TD>
        </TR>
</TABLE>

<p>А если строковое выражение будет содержать лишь одну букву? Запрос выведет ее. В этом легко убедиться, написав</p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT * FROM ( <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT class +' '+ name AS cn FROM Ships<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNION ALL <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'a' as nc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) x <br>
WHERE LEFT(cn, 1)=RIGHT(cn, 1)
</td></tr> </table><br>
<p>Чтобы исключить этот случай, можно воспользоваться еще одной полезной функцией <b>LEN (&lt;<i>строковое выражение</i>>)</b>, которая возвращает число символов в строке. Ограничимся случаем, когда число символов больше единицы:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT * FROM ( <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT class +' '+ name AS cn FROM Ships<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNION ALL <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'a' as nc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) x <br>
WHERE LEFT(cn, 1)=RIGHT(cn, 1) AND LEN(cn)>1
</td></tr> </table><br>
<p><b>Замечание</b>. <a name=len>Реализация этой функции</a> в MS SQL Server имеет одну особенность, а именно, при подсчете длины не учитываются концевые пробелы.<br>
Действительно, выполним следующий код:<br><br>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
DECLARE @chr AS CHAR(12), @vchr AS VARCHAR(12)<br>  <br>
SELECT @chr = 'abcde' + REPLICATE(' ', 5), @vchr = 'abcde'+REPLICATE(' ', 5)<br><br>
SELECT LEN(@chr), LEN(@vchr)<br>
SELECT DATALENGTH(@chr), DATALENGTH(@vchr)
</td></tr> </table><br>
<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD BGCOLOR="#DDDDDD">5</TD>                <TD BGCOLOR="#DDDDDD">5</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">12</TD>                <TD BGCOLOR="#DDDDDD">10</TD>
        </TR>
</TABLE> <br>
<p>Функция <b>REPLICATE</b> дополняет константу 'abcde' пятью пробелами справа, которые не учитываются функцией <b>LEN</b>, - в обоих случаях получаем 5.<br>
Функция <b>DATALENGTH</b> возвращает число байтов в представлении переменной и демонстрирует нам различие между типами CHAR и VARCHAR. <b>DATALENGTH</b> даст нам 12 для типа CHAR и 10 - для VARCHAR.<br>
Как и следовало ожидать, <b>DATALENGTH</b> для переменной типа VARCHAR вернула фактическую длину переменной. Но почему для переменной типа CHAR результат
оказался равным 12? Дело в том, что CHAR - это тип <i>фиксированной длины</i>. Если значение переменной оказывается меньше ее длины, а длину мы объявили как CHAR(12), то значение переменной будет "выровнено" до требуемой длины за счет добавления концевых пробелов.
</p>
<p>На сайте имеются задачи, в которых требуется упорядочить (найти максимум и т.д.) в числовом порядке значения, представленные в текстовом формате. Например, номер места в самолете ("2d") или скорость CD ("24x"). Проблема заключается в том, что текст сортируется так (по возрастанию)</p>

<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD ALIGN="center" BGCOLOR="#CCCCCC">11a</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">1a </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">2a</TD>
        </TR>
</TABLE>
<p>Действительно,</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT '1a' AS place  <br>
UNION ALL SELECT '2a' <br>
UNION ALL SELECT '11a'<br>
ORDER BY 1
</td></tr> </table><br>
<p>Если же требуется упорядочить места в порядке возрастания рядов, то порядок должен быть такой</p>

<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD ALIGN="center" BGCOLOR="#CCCCCC">1a</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">2a </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">11a</TD>
        </TR>
</TABLE>
<p>Чтобы добиться такого порядка, нужно выполнить сортировку по числовым значениям, присутствующим в тексте. Можно предложить такой алгоритм:<br>
1. Извлечь число из строки.<br>
2. Привести его к числовому формату. <br>
3. Выполнить сортировку по приведенному значению.</p>

<p>Т.к. нам известно, что буква только одна, то для извлечения числа из строки можно воспользоваться следующей конструкцией, которая не зависит от числа цифр в номере места:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
LEFT(place, LEN(place)-1)
</td></tr> </table><br>
<p>Если только этим и ограничиться, то получим</p>
<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD ALIGN="center" BGCOLOR="#D3DCE3"><B>place</B></TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">1a </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">11a</TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">2a</TD>
        </TR>
</TABLE>
<p>Приведение к числовому формату может быть следующим:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
CAST (LEFT(place, LEN(place)-1) AS INT)
</td></tr> </table><br>
<p>Осталось выполнить сортировку</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT * FROM (<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT '1a' AS place  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNION ALL SELECT '2a' <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNION ALL SELECT '11a'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) x <br>
ORDER BY CAST(LEFT(place, LEN(place)-1) AS INT)
</td></tr> </table><br>

<p>Что и требовалось доказать.</p>
<p>Ранее мы для извлечения числа из текстовой строки пользовались функцией LEFT, т.к. нам было известно априори, какое число символов нужно убрать справа (один). А если же нужно извлечь строку из подстроки не по известной позиции символа, а по самому символу? Например: извлечь все символы до первой буквы "х" (значение скорости CD).</p>
<p>В этом случае мы можем использовать также уже рассмотренную ранее функцию CHARINDEX, которая позволит определить неизвестную позицию символа:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT model, LEFT(cd, CHARINDEX('x', cd) -1) FROM PC
</td></tr> </table><br>
<h2>Функция SUBSTRING</h2>
<p><b>SUBSTRING (&lt;<i>выражение</i>>, &lt;<i>начальная позиция</i>>, &lt;<i>длина</i>> ) </b></p>

<p>Эта функция позволяет извлечь из выражения его часть заданной длины, начиная от заданной начальной позиции. Выражение может быть символьной или бинарной строкой, а также иметь тип <b>text</b> или <b>image</b>. Например, если нам потребуется получить 3 символа в названии корабля, начиная со 2-го символа, то сделать без помощи функции SUBSTRING будет не так просто. А так мы пишем:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, SUBSTRING(name, 2, 3) FROM Ships
</td></tr> </table><br>
<p>В случае, когда нужно извлечь все символы, начиная с некоторого, мы также можем использовать эту функцию. Например,</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, SUBSTRING(name, 2, LEN(name)) FROM Ships
</td></tr> </table><br>
<p>даст нам все символы в названиях кораблей от второй буквы в имени. Обратите внимание на то, что для указания числа извлекаемых символов я использовал функцию LEN(name), которая возвращает число символов в имени. Понятно, что поскольку мне нужны символы, начиная со второго, то их число будет меньше общего количества символов в имени. Однако это не вызывает ошибки, поскольку если указанное число символов превышает возможное число, то будут извлечены все символы до конца строки. Поэтому я и беру их с запасом, не утруждая себя вычислениями.</p>
<h2>Функция REVERSE</h2>
<p>Эта функция переворачивает строку, как бы читая ее справа налево. Т.е. результатом запроса</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT REVERSE('abcdef')
</td></tr> </table><br>
<p>будет 'fedcba'. Если бы в языке отсутствовала функция RIGHT, то запрос</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT RIGHT('abcdef',3)
</td></tr> </table><br>
<p>можно было бы равносильно заменить запросом</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT REVERSE(LEFT(REVERSE('abcdef'),3))
</td></tr> </table><br>
<p>Я вижу пользу этой функции в следующем. Пусть нам требуется определить позицию не первого, а последнего вхождения некоторого символа (или последовательности символов) в строке. Вспомним пример, в котором мы определяли позицию первого символа "а" в названии корабля "California":</p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT CHARINDEX('a', name) first_a<br>
FROM Ships WHERE name='California'
</td></tr> </table><br>

<p>Определим теперь позицию последнего вхождения в это название символа "а". Функция</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
CHARINDEX('a', REVERSE(name))
</td></tr> </table><br>
<p>позволит найти эту позицию, но справа. Для получения позиции этого же символа слева достаточно написать</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT LEN(name) + 1 - CHARINDEX('a', REVERSE(name)) first_a <br>
FROM Ships WHERE name='California'
</td></tr> </table><br>
<h2>Функция REPLACE</h2>

<p><b>REPLACE ( &lt;<i>строка1</i>> , &lt;<i>строка2</i>> , &lt;<i>строка3</i>> )</b></p>

<p>Заменяет в <i>строке1</i> все вхождения <i>строки2</i> на <i>строку3</i>. Эта функция, безусловно, полезна в операторах обновления (<b>UPDATE</b>), если нужно изменить (исправить) содержимое столбца. Пусть, например, нужно заменить все пробелы дефисом в названиях кораблей. Тогда можно написать</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
UPDATE Ships                                                 <br>
SET name = REPLACE(name, ' ', '-')
</td></tr> </table><br>
<p>(Этот пример можно выполнить на странице с упражнениями <a href="http://www.sql-ex.ru/dmlexercises.php.html">DML</a>, где разрешаются запросы на изменение данных)</p>

<p>Однако эта функция может найти применение и в более нетривиальных случаях. Давайте определим, сколько раз в названии корабля используется буква "a". Идея проста: заменим каждую искомую букву двумя любыми символами, после чего посчитаем разность длин полученной и искомой строки. Итак,</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, LEN(REPLACE(name, 'a', 'aa')) - LEN(name) FROM Ships
</td></tr> </table><br>
<p>А если нам нужно определить число вхождений произвольной последовательности символов, скажем, передаваемой в качестве параметра в хранимую процедуру? Использованный выше алгоритм в этом случае следует дополнить делением на число символов в искомой последовательности:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
DECLARE @str AS VARCHAR(100)                                 <br>
SET @str='ma'                                                    <br>
SELECT name, (LEN(REPLACE(name, @str, @str + @str)) - LEN(name))/LEN(@str) FROM Ships
</td></tr> </table><br>
<p>Для удвоения числа искомых символов здесь применялась конкатенация - @str + @str . Однако для этой цели можно использовать еще одну функцию - <b>REPLICATE</b>, которая повторяет первый аргумент такое число раз, которое задается вторым аргументом.</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, (LEN(REPLACE(name, @str, REPLICATE(@str, 2))) - LEN(name))/LEN(@str) FROM Ships
</td></tr> </table><br>
<p>Т.е. мы повторяем дважды подстроку, хранящуюся в переменной @str .</p>

<p>Если же нужно заменить в строке не определенную последовательность символов, а заданное число символов, начиная с некоторой позиции, то проще использовать функцию <b>STUFF</b>:</p>

<p><b>STUFF (&lt;<i>строка1</i>> , &lt;<i>стартовая позиция</i>> , &lt;<i>L</i>> , &lt;<i>строка2</i>>)</b>       </p>

<p>Эта функция заменяет подстроку длиной <i>L</i>, которая начинается со стартовой позиции в <i>строке1</i>, на <i>строку2</i>.</p>

<p><b>Пример</b>. Изменить имя корабля: оставив в его имени 5 первых символов, дописать "_" (нижнее подчеркивание) и год спуска на воду. Если в имени менее 5 символов, дополнить его пробелами.</p>

<p>Можно решать эту задачу с помощью разных функций. Мы же попытаемся это сделать с помощью функции STUFF. В первом приближении напишем (ограничимся запросом на выборку):</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, STUFF(name, 6, LEN(name), '_'+launched) FROM Ships
</td></tr> </table><br>
<p>Третьим аргументом (количество символов для замены) я использую LEN(name), т.к. мне нужно заменить все символы до конца строки, поэтому я беру с запасом - исходное число символов в имени. И все же этот запрос вернет ошибку. Причем дело не в третьем аргументе, а в четвертом, где выполняется конкатенация строковой константы и числового столбца. Ошибка приведения типа. Для преобразования числа к его строковому представлению можно воспользоваться еще одной встроенной функцией - <b>STR</b>:</p>

<p><b>STR ( &lt;<i>число с плавающей точкой</i>> [ , &lt;<i>длина</i>> [ , &lt;<i>число десятичных знаков</i>> ] ] )</b></p>

<p>При этом преобразовании выполняется округление, а длина задает длину результирующей строки. Например,  </p>

<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD BGCOLOR="#DDDDDD">STR(3.3456, 5, 1) </TD>
                <TD BGCOLOR="#DDDDDD"> &nbsp;&nbsp;&nbsp;&nbsp;3.3  </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">STR(3.3456, 5, 2)</TD>
                <TD BGCOLOR="#CCCCCC">&nbsp;&nbsp;3.35  </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#DDDDDD">STR(3.3456, 5, 3) </TD>
                <TD BGCOLOR="#DDDDDD">3.346  </TD>
        </TR>
        <TR>
                <TD BGCOLOR="#CCCCCC">STR(3.3456, 5, 4)</TD>
                <TD BGCOLOR="#CCCCCC">3.346  </TD>
        </TR>

</TABLE>

<p>Обратите внимание, что если полученное строковое представление числа меньше заданной длины, то добавляются лидирующие пробелы. Если же результат больше заданной длины, то усекается дробная часть (с округлением); в случае же целого числа получаем соответствующее число звездочек "*":</p>
<TABLE border="0" cellpadding="5" align="center">
        <TR>
                <TD BGCOLOR="#CCCCCC">STR(12345,4,0)     </TD>
                <TD BGCOLOR="#CCCCCC">****</TD>
        </TR>

</TABLE>

<p>Кстати, по умолчанию используется длина в 10 символов. Имея в виду, что год представлен четырьмя цифрами, напишем</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, STUFF(name, 6, LEN(name), '_'+STR(launched, 4)) FROM Ships
</td></tr> </table><br>

<p>Уже почти все правильно. Осталось учесть случай, когда число символов в имени менее 6, т.к. в этом случае функция STUFF дает NULL. Ну что ж вытерпим до конца мучения, связанные с использованием этой функции в данном примере, попутно применив еще одну строковую функцию.
Добавим конечные пробелы, чтобы длина имени была заведомо больше 6. Для этого имеется специальная функция <b>SPACE</b>
</p>
<p><b>SPACE(&lt;<i>число пробелов</i>>)</b>:  </p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name, STUFF(name + SPACE(6), 6, LEN(name), '_'+STR(launched,4)) FROM Ships
</td></tr> </table><br>
<h2>Функции LTRIM и RTRIM                                        </h2>

<p><b>LTRIM (&lt;<i>строковое выражение</i>>)    </b>     </p>

<p><b>RTRIM (&lt;<i>строковое выражение</i>>)    </b>     </p>

<p>отсекают соответственно лидирующие и конечные пробелы строкового выражения, которое неявно приводится к типу <b>VARCHAR</b>.</p>

<p>Пусть требуется построить такую строку: <i>имя пассажира</i>_<i>идентификатор пассажира</i> для каждой записи из таблицы Passenger. Если мы напишем</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT name + '_' + CAST(id_psg AS VARCHAR) FROM Passenger,
</td></tr> </table><br>
<p>то в результате получим что-то типа:                         </p>

<p>A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               _1</p>

<p>Это связано с тем, что столбец name имеет тип <b>CHAR</b>(30). Для этого типа короткая строка дополняется пробелами до заданного размера (у нас 30 символов). Здесь нам как раз и поможет функция RTRIM:</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT RTRIM(name) + '_' + CAST(id_psg AS VARCHAR) FROM Passenger
</td></tr> </table><br>
<h2>Функции LOWER и UPPER                                        </h2>

<p><b>LOWER(&lt;<i>строковое выражение</i>>)</b> </p>

<p><b>UPPER(&lt;<i>строковое выражение</i>>)</b>  </p>

<p>преобразуют все символы аргумента соответственно к нижнему и верхнему регистру. Эти функции оказываются полезными при сравнении регистрозависимых строк.</p>

<p>Пара интересных функций <b>SOUNDEX</b> и <b>DIFFERENCE:</b>  </p>

<p><b>SOUNDEX(&lt;<i>строковое выражение</i>>)</b></p>

<p><b>DIFFERENCE (&lt;<i>строковое выражение_1</i>>, &lt;<i>строковое выражение_2</i>>)</b></p>

<p>Позволяют определить близость звучания слов. При этом SOUNDEX возвращает четырехсимвольный код, используемый для сравнения, а DIFFERENCE собственно и оценивает близость звучания двух сравниваемых строковых выражений. Поскольку эти функции не поддерживают кириллицы, отсылаю интересующихся к BOL за примерами их использования.</p>

<p>В заключение приведем функции и несколько примеров использования юникода.</p>

<h2>Функция UNICODE</h2>

<p><b>UNICODE (&lt;<i>строковое выражение</i>>)</b>      </p>

<p>возвращает юникод первого символа строкового выражения.       </p>

<h2>Функция NCHAR</h2>

<p><b>NCHAR (&lt;<i>целое</i>>)  </b></p>

<p>возвращает символ по его юникоду. Несколько примеров.      </p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT ASCII('а'), UNICODE('а')
</td></tr> </table><br>
<p>возвращает код ASCII и юникод русской буквы "а": 224 и 1072. </p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT CHAR(ASCII('а')), CHAR(UNICODE('а'))
</td></tr> </table><br>
<p>Пытаемся восстановить символ по его коду. Получаем "а" и NULL. NULL-значение возвращается потому, что кода 1072 нет в обычной кодовой таблице.</p>
<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT CHAR(ASCII('а')), NCHAR(UNICODE('а'))
</td></tr> </table><br>
<p>Теперь все нормально, в обоих случаях "а". Наконец, </p>

<TABLE border="0" cellpadding="5" ><tr><td bgcolor="#D3DCE3">
SELECT NCHAR(ASCII('а'))
</td></tr> </table><br>
<p>даст "a", т.к. юникод 224 соответствует именно этой букве.   </p>

<p>Приведенные здесь примеры можно выполнить непосредственно на сайте, установив флажок "Без проверки" на странице с упражнениями на <a href="http://www.sql-ex.ru/exercises.php.html">SELECT</a>.</p>
</div><center>
<br><br>
<small>

</small>
<br><br>
</center>
<p></p>
<!-- раскраска -->
  	<script type="text/javascript">
      hljs.initHighlightingOnLoad('sql');
    </script>

<center>
<a href="select9.php.html">Назад</a> | <a href="select0.php.html">Содержание</a> | <a href="select11.php.html">Вперед</a><br><br>
<!-- Яндекс.Директ -->
<script type="text/javascript">
yandex_partner_id = 184442;
yandex_site_bg_color = 'FFFFFF';
yandex_ad_format = 'direct';
yandex_font_size = 0.9;
yandex_direct_type = 'horizontal';
yandex_direct_border_type = 'block';
yandex_direct_limit = 2;
yandex_direct_title_font_size = 2;
yandex_direct_links_underline = false;
yandex_direct_header_bg_color = 'FEEAC7';
yandex_direct_border_color = 'FBE5C0';
yandex_direct_title_color = '0000CC';
yandex_direct_url_color = '006600';
yandex_direct_text_color = '000000';
yandex_direct_hover_color = '0066FF';
yandex_direct_sitelinks_color = '0000CC';
yandex_direct_favicon = true;
yandex_no_sitelinks = false;
document.write('<scr'+'ipt type="text/javascript" src="//an.yandex.ru/system/context.js"></scr'+'ipt>');
</script><br><style>
span.c4b5cf {
padding: 5px !important;
text-align: left !important;
font-size: 10px !important;
background-color: transparent !important;
border: 1px solid #e0e0e0 !important;
}
.c4b5cf a {
color: #6A0000 !important;
font-weight: normal;
font-size: 10px !important;
}
.c4b5cf .text {
color: #000000 !important;
font-size: 10px !important;
padding: 3px 0 !important;
line-height: normal !important;
}
.c4b5cf .host {
color: #006600;
font-weight: normal;
font-size: 10px !important;
padding: 3px 0 !important;
line-height: normal !important;
}
</style>
<span class="c4b5cf">

  <span>
    
<span class="text"><a href="http://s-ds.ru/ecolog_learn/seminar/" target="_blank">Семинары по экологии</a></span><br />
<span class="host">s-ds.ru</span>

  </span><br />

</span>
</center>

<br>
<table width="98%" border="0" align="center" cellpadding="0" cellspacing="0" bgcolor="#CCCCCC" valign="middle">
 <tr>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/" style="font-size: 8pt;">Начало</A></td>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/exercises.php.html" target="exercises" style="font-size: 8pt;">Упражнения <b>SELECT (рейтинговые этапы)</b></A></td>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/dmlexercises.php.html" target="exercises" style="font-size: 8pt;">Упражнения <b>DML</b></A></td>
 <td align="center" width="15%" onmouseout="this.style.backgroundColor='#CCCCCC'" onmouseover="this.style.backgroundColor='#DDDDDD'"><A href="/developers.php.html" style="font-size: 8pt;">Разработчики</A></td>
 <td align="left" width="20%">
<!--begin of Top100 logo-->
<noindex>
<a href="http://top100.rambler.ru/top100/">
<img src="http://top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100" width="88" height="31" border="0"></a>
</noindex>
<!--end of Top100 logo -->

<!--LiveInternet counter--><script language="JavaScript"><!--
document.write('<a href="http://www.liveinternet.ru/click" '+
'target="_blank"><img src="http://counter.yadro.ru/hit?t16.2;r'+
escape(document.referrer)+((typeof(screen)=='undefined')?'':
';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
';'+Math.random()+'" title="liveinternet.ru: число просмотров и посетителей за сутки и за сегодня" border="0" width="88" height="31"></a>')//--></script>
<!--/LiveInternet-->

<!--uptolike -->
<script type="text/javascript">(function(w,doc) {
if (!w.__utlWdgt ) {
    w.__utlWdgt = true;
    var d = doc, s = d.createElement('script'), g = 'getElementsByTagName';
    s.type = 'text/javascript'; s.charset='UTF-8'; s.async = true;
    s.src = ('https:' == w.location.protocol ? 'https' : 'http')  + '://w.uptolike.com/widgets/v1/uptolike.js';
    var h=d[g]('body')[0];
    h.appendChild(s);
}})(window,document);
</script>
<div data-background-alpha="0.0" data-orientation="horizontal" data-text-color="000000" data-share-shape="round-rectangle" data-buttons-color="ff9300" data-sn-ids="fb.tw.ok.vk.gp.mr." data-counter-background-color="ffffff" data-share-counter-size="10" data-share-size="20" data-background-color="ededed" data-share-counter-type="common" data-pid="1257631" data-counter-background-alpha="1.0" data-share-style="1" data-mode="share" data-following-enable="false" data-like-text-enable="false" data-selection-enable="true" data-icon-color="ffffff" class="uptolike-buttons" ></div>
<!--uptolike -->

 </td></tr>
</table>
</body></html>